import { describe, expect, test } from "vitest";
import { eachIndex } from "../../helpers.js";
import { allTestData } from "~/test/all-data-tests.js";
import {
  BaseSequenceRunner,
  FormatDataSource,
  TestGameStateSnapshot,
} from "../../../test/framework.js";
import { CellTestData } from "../../../test/helpers/ascii-grid.js";
import {
  SmartFillTileState,
  SuggestTileState,
  TileState,
  TrackedStatesIndexList,
} from "../types/index.js";
import { calculatedSolveState } from "./solve-state.js";
import { SolveStep } from "../types/solve-state.js";

describe("calculatedSolveState", () => {
  allTestData(
    (title, ...states) => {
      test(typeof title === "string" ? title : title.title, async () => {
        await new SolveStateSequenceRunner().testSequence(states);
      });
    },
    { describe }
  );

  class SolveStateSequenceRunner extends BaseSequenceRunner {
    static #smartFillMap = {
      [TileState.Blocked]: SmartFillTileState.SmartFillBlocked,
      [TileState.Sword]: SmartFillTileState.SmartFillSword,
      [TileState.Present]: SmartFillTileState.SmartFillPresent,
    };
    #userSelected: TileState[];

    constructor() {
      super((message) => expect.unreachable(message), expect);
      this.#userSelected = Array.from(this.indexes()).map(
        () => TileState.Unknown
      );
    }

    protected setUserSelection(
      index: number,
      tileState: TileState
    ): void | Promise<void> {
      this.#userSelected[index] = tileState;
    }

    protected override formatSuggestions(
      source: FormatDataSource,
      index: number,
      data: { str: string },
      prompt: SuggestTileState | undefined,
      suggestion: { Sword: number; Present: number; Fox: number } | undefined,
      recommended: boolean | undefined
    ): void {
      // We ignore prompts because prompts are generated by the solver, not us.
      super.formatSuggestions(
        source,
        index,
        data,
        undefined,
        suggestion,
        recommended
      );
    }

    protected getState(): TestGameStateSnapshot {
      const { solveState, issues } = this.calculateSolveState();
      const cells: CellTestData[] = [];
      for (const index of this.indexes()) {
        const smartFill = solveState.getSmartFill(index);
        const suggestion = solveState.getSuggestion(index);
        const finalWeight = solveState.getFinalWeight(index);
        const data: CellTestData = {
          userSelection: this.#userSelected[index],
          smartFill:
            smartFill !== null
              ? SolveStateSequenceRunner.#smartFillMap[smartFill]
              : null,
        };
        data.suggestions = suggestion ?? undefined;
        data.recommended =
          solveState.solveStep !== SolveStep.SuggestFoxes &&
          finalWeight !== null &&
          finalWeight.value > 0 &&
          solveState.getMaxTileWeight() === finalWeight.value;

        cells.push(data);
      }

      return {
        cells,
        issues,
        patternData: {
          patternIdentifier: solveState.getPatternIdentifier(),
          remainingPatterns: solveState.totalCandidatePatterns,
        },
        debug: `Solve Step: ${
          solveState.solveStep
        } | Pattern: ${solveState.getPatternIdentifier()}`,
      };
    }
    protected calculateSolveState() {
      const userStatesIndexList: TrackedStatesIndexList<Set<number>> = {
        [TileState.Blocked]: new Set<number>(),
        [TileState.Present]: new Set<number>(),
        [TileState.Sword]: new Set<number>(),
        [TileState.Fox]: new Set<number>(),
        [TileState.Empty]: new Set<number>(),
      };
      for (const [j, cell] of eachIndex(this.#userSelected)) {
        if (cell in userStatesIndexList) {
          userStatesIndexList[
            cell as keyof TrackedStatesIndexList<Set<number>>
          ].add(j);
        }
      }
      return calculatedSolveState(this.#userSelected, userStatesIndexList);
    }
  }
});
